"""
    re库：
    1. match：从开始的位置进行匹配，如果开始的位置没有匹配到，就直接失败了
    2. search：在字符串中找满足条件的字符，如果找到，就返回，只会找到第一个满足条件的
    3. group 分组：在正则表达式中，可以对过滤到的字符串进行分组。分组使用圆括号的方式

    4. findall: 找出所有满足条件的，找到()里面的， 返回的是一个列表
    5. sub: 用来替换字符串，将匹配到的字符串替换为其他字符串 ，返回一个字符串类型
    6. split：使用正则表达式来分割字符串, 返回的是一个列表
    7. compile: 对于一些经常要用到的正则表达式，可以使用compile进行编译，后期再使用的时候
                可以直接拿过来用，执行效率会更快.
                而且，compile还可以指定 flag = re.VERBOSE ，可以分行写正则表达式，每行可以加上注释
"""
import re


# .group 分组的用法
text = "apple's price $99 , orange's price is $10"
# 整个正则表达式是叫 整体分组， 里面的() 叫做 子分组
ret = re.search('.*(\$\d+).*(\$\d+)', text)
print(ret)

ret.group()  # 取出整个分组 也就是整个正则表达式所匹配的  在外圈隐藏了个()
# print(ret.group(0)) 等价于 .group()

ret.group(1)  # 在正则表达式中用() 括起来了，获取第一个分组  $99
ret.group(2)  # $10
ret.group(1, 2)  # $99 $10

# 取出所有的子分组  : .groups()
ret.groups()

"""
    findall的使用: 找到 () 里面的
        re.DOTALL 获取里面的所有字符  包括 \n ....
"""
ret = re.findall('.*(\$\d+).*(\$\d+)', text, re.DOTALL)
print(ret)


"""
    sub的使用: 参数count替换几个，默认是全部
"""
ret = re.sub('\$\d+', "0", text, count=1)
# print(ret)

# sub的案例 提取标签中的所有 文本
html_doc = """
    <dd class="job_bt">
        <h3 class="description">职位描述：</h3>
        <div>
        <p>后端工程师</p>
<p>任职要求：</p>
<p>1.&nbsp;良好的沟通能力，团队合作精神，学习能力，有责任感，有实际后端产品的开发经验</p>
<p>2.&nbsp;熟悉掌握Web开发相关知识</p>
<p>3.&nbsp;熟悉Python语言，以及Django或类似Web框架</p>
<p>4.&nbsp;熟练使用&nbsp;MySQL，掌握常用的基础语句，熟悉基本索引优化</p>
<p>工作职责：</p>
<p>1.&nbsp;设计、开发、优化服务器后端</p>
<p>2.&nbsp;不断优化技术实现，提升自己和团队的工作、生活质量</p>
<p>加分项：</p>
<p>1.&nbsp;熟悉Unix&nbsp;shell</p>
<p>2.&nbsp;有后端系统架构设计经验，兼顾性能、可扩展性</p>
<p>3.&nbsp;熟悉Redis的使用</p>
<p>4.&nbsp;熟悉和理解异步开发框架或模型</p>
<p>5.&nbsp;参加或主导过开源项目</p>
        </div>
    </dd>
"""
# 注意：要加 ? 变成非贪婪模式
ret = re.sub('<.+?>', "", html_doc)
# print(ret)


"""
    split的使用：返回列表
"""
sp = 'hello,ni;hao,a'
ret = re.split(',|;', sp)
ret2 = re.split('[^a-z]', sp)
# print(ret)
# print(ret2)


"""
    compile: 的使用
"""
nu = 'the number is 20.50'
comp = re.compile('\d+\.?\d*')  # 取出数字

# 注意加上 re.VERBOSE 参数
comp2 = re.compile(r"""
    \d+   # 小数点前面的数 
    \.?   # 小数点
    \d*   # 小数点后面的数
""", re.VERBOSE)

ret = re.search(comp, nu)
ret2 = re.search(comp2, nu)
# print(ret.group())
# print(ret2.group())

"""

    模式      	描述
    ^	        匹配字符串的开头
    $	        匹配字符串的末尾。
    .	        匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
    [...]	    用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
    [^...]	    不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
    re*	        匹配0个或多个的表达式。
    re+     	匹配1个或多个的表达式。
    re?	        匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
    re{ n}     	精确匹配 n 个前面表达式。例如， o{2} 不能匹配 "Bob" 中的 "o"，但是能匹配 "food" 中的两个 o。
    re{ n,}	    匹配 n 个前面表达式。例如， o{2,} 不能匹配"Bob"中的"o"，但能匹配 "foooood"中的所有 o。"o{1,}" 等价于 "o+"。"o{0,}" 则等价于 "o*"。
    re{ n, m}	匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
    a| b	    匹配a或b
    (re)	    匹配括号内的表达式，也表示一个组
    (?imx)	    正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
    (?-imx) 	正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
    (?: re)	    类似 (...), 但是不表示一个组
    (?imx: re)	在括号中使用i, m, 或 x 可选标志
    (?-imx: re)	在括号中不使用i, m, 或 x 可选标志
    (?#...)	    注释.
    (?= re)	    前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
    (?! re)	    前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
    (?> re)	    匹配的独立模式，省去回溯。
    \w	        匹配字母数字及下划线
    \W	        匹配非字母数字及下划线
    \s	        匹配任意空白字符，等价于 [\t\n\r\f].
    \S	        匹配任意非空字符
    \d	        匹配任意数字，等价于 [0-9].
    \D	        匹配任意非数字
    \A	        匹配字符串开始
    \Z	        匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。
    \z	        匹配字符串结束
    \G	        匹配最后匹配完成的位置。
    \b	        匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
    \B	        匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
    \n, \t, 等.	匹配一个换行符。匹配一个制表符。等
    \1...\9	    匹配第n个分组的内容。
    \10	        匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。
"""